/*
 * generated by Xtext 2.21.0
 */
package org.xtext.mdsd.arduino.boardgenerator.validation

import com.google.inject.Inject
import java.util.HashSet
import java.util.List
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import org.xtext.mdsd.arduino.boardgenerator.ioT.AbstractBoard
import org.xtext.mdsd.arduino.boardgenerator.ioT.And
import org.xtext.mdsd.arduino.boardgenerator.ioT.Board
import org.xtext.mdsd.arduino.boardgenerator.ioT.Reference 
import org.xtext.mdsd.arduino.boardgenerator.ioT.BoardVersion
import org.xtext.mdsd.arduino.boardgenerator.ioT.Conditional
import org.xtext.mdsd.arduino.boardgenerator.ioT.Div
import org.xtext.mdsd.arduino.boardgenerator.ioT.Equal
import org.xtext.mdsd.arduino.boardgenerator.ioT.Exponent
import org.xtext.mdsd.arduino.boardgenerator.ioT.Expression
import org.xtext.mdsd.arduino.boardgenerator.ioT.ExtendsBoard
import org.xtext.mdsd.arduino.boardgenerator.ioT.External
import org.xtext.mdsd.arduino.boardgenerator.ioT.ExternalSensor
import org.xtext.mdsd.arduino.boardgenerator.ioT.GreaterThan
import org.xtext.mdsd.arduino.boardgenerator.ioT.GreaterThanEqual
import org.xtext.mdsd.arduino.boardgenerator.ioT.IoTPackage
import org.xtext.mdsd.arduino.boardgenerator.ioT.LessThan
import org.xtext.mdsd.arduino.boardgenerator.ioT.LessThanEqual
import org.xtext.mdsd.arduino.boardgenerator.ioT.Map
import org.xtext.mdsd.arduino.boardgenerator.ioT.Minus
import org.xtext.mdsd.arduino.boardgenerator.ioT.Model
import org.xtext.mdsd.arduino.boardgenerator.ioT.MqttClient
import org.xtext.mdsd.arduino.boardgenerator.ioT.Mul
import org.xtext.mdsd.arduino.boardgenerator.ioT.Negation
import org.xtext.mdsd.arduino.boardgenerator.ioT.NewBoard
import org.xtext.mdsd.arduino.boardgenerator.ioT.Not
import org.xtext.mdsd.arduino.boardgenerator.ioT.EmbeddedSensor
import org.xtext.mdsd.arduino.boardgenerator.ioT.Or
import org.xtext.mdsd.arduino.boardgenerator.ioT.Pipeline
import org.xtext.mdsd.arduino.boardgenerator.ioT.Plus
import org.xtext.mdsd.arduino.boardgenerator.ioT.Reference
import org.xtext.mdsd.arduino.boardgenerator.ioT.Sensor
import org.xtext.mdsd.arduino.boardgenerator.ioT.SensorVariables
import org.xtext.mdsd.arduino.boardgenerator.ioT.Unequal
import org.xtext.mdsd.arduino.boardgenerator.ioT.Variable
import org.xtext.mdsd.arduino.boardgenerator.ioT.WindowPipeline
import org.xtext.mdsd.arduino.boardgenerator.scoping.IoTGlobalScopeProvider
import org.xtext.mdsd.arduino.boardgenerator.typeChecker.TypeChecker

import static extension org.eclipse.xtext.EcoreUtil2.*
import org.xtext.mdsd.arduino.boardgenerator.ioT.Channel
import org.xtext.mdsd.arduino.boardgenerator.ioT.WifiConfig
import org.xtext.mdsd.arduino.boardgenerator.ioT.SensorOutput
import org.xtext.mdsd.arduino.boardgenerator.ioT.Function
import org.xtext.mdsd.arduino.boardgenerator.ioT.ChannelType
import java.util.Arrays
import org.eclipse.emf.ecore.EAttribute
import org.xtext.mdsd.arduino.boardgenerator.ioT.MapPipeline
import org.xtext.mdsd.arduino.boardgenerator.ioT.Cloud
import org.xtext.mdsd.arduino.boardgenerator.ioT.FunctionInputType
import org.xtext.mdsd.arduino.boardgenerator.ioT.Command
import org.xtext.mdsd.arduino.boardgenerator.ioT.SDConfig

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class IoTValidator extends AbstractIoTValidator { 
	  
	public static val NO_SUPPORT_FOR_SENSOR = "org.xtext.mdsd.arduino.boardgenerator.NoSupportForSensor"
	public static val INVALID_FUNCTION_TYPE = "org.xtext.mdsd.arduino.boardgenerator.InvalidFunctionType" 
	public static val INVALID_CHANNEL_TYPE = "org.xtext.mdsd.arduino.boardgenerator.InvalidChannelType" 
	
	@Inject
	IoTGlobalScopeProvider scopeProvider
	
	@Inject 
	extension TypeChecker
	
	@Check  
	def validateExternalSensor(Sensor sensor){
		val vcc = sensor.getVcc(); 
		val externalSensor = sensor.sensortype;
		if (externalSensor instanceof ExternalSensor){ 
			if (externalSensor.pins.size() != sensor.vars.ids.size()){
				error('''number of vars must equal «externalSensor.pins.size()»''', IoTPackage.Literals.SENSOR__VARS); 
			}       
			if (vcc < 1){
				info("this declaration of sensor might need vcc", IoTPackage.eINSTANCE.sensor_Name); 
			} 
		}
		val list = sensor.vars.ids.construct
		val set = new HashSet<String>(list)
		if (set.size() != list.size()){ 
			error("variables must be unique", IoTPackage.Literals.SENSOR__VARS);
		}
		 
		if (externalSensor instanceof EmbeddedSensor && vcc > 0){   
			warning("supported sensors does not require vcc", IoTPackage.eINSTANCE.sensor_Vcc)
		}   
	} 
	
	def List<String> construct(List<Variable> variables){
		val list = newArrayList() 
		var counter = 0
		for (Variable v : variables){
			val name = v.name			
			if (name == "_"){
				list.add(name + counter.toString)
				counter++
			} else {
				list.add(name)
			}
		}
		list
	}
		
	@Check
	def validateExpressionVariables(Expression expression){
		
		if (expression instanceof Reference){
			val reference = expression as Reference
			var parent = reference.getContainerOfType(Pipeline).pipelineChildOf
			
			if (parent === null){	 			 
				val sensor = expression.getContainerOfType(Sensor)
				var error = true
				for (Variable v : sensor.vars.ids){   
					if (reference.ref == v.name) error = false 
				}  
				if (error)      
					error('''variable "«reference.ref»" was not declared''', IoTPackage.eINSTANCE.reference_Ref);
					
			} else if (parent instanceof Map){   
				var map = parent as Map 
				if ( map.output.name != reference.ref)
					error('''only variable "«map.output.name»" is reachable after map function''', IoTPackage.eINSTANCE.reference_Ref);
			} else if (parent instanceof External){   
				var external = parent as External
				var index = external.function.output.indexOf(reference.ref) 
				if (index < 0){  
					error('''"«reference.ref»" not reachable''', IoTPackage.eINSTANCE.reference_Ref)
				}
			}	
		}  
	}
	
	@Check
	def validateFunction(External external){ 
		var functionOutput = external.function.input.size() 
		if(external.input.size() != functionOutput){
			val inputs = newArrayList()  
			external.function.input.forEach[i | inputs.add(i)] 
			error('''input does not match declared function «external.function.name»«inputs.toString.replace('[', '(').replace(']', ')')»''', IoTPackage.eINSTANCE.external_Function)
		} 
		var sensor = external.getContainerOfType(Sensor)
		for (i:0 ..< functionOutput){  
			if (external.input.size() < 1){
				return 
			}
			try{
				var inputType = (external.input.get(i) as Expression).type			
				var acceptedInputType = external.function.input.get(i).type
				    
				if (acceptedInputType.isNumberType){
					inputType.validateNumbers(IoTPackage.eINSTANCE.external_Input) 
				} else {  
					inputType.validateTypes(acceptedInputType, IoTPackage.eINSTANCE.external_Input)
				}
				   
				if (sensor !== null){
					
					var functionOutputID = external.function.output.get(i)   
					var index = sensor.vars.ids.asStringList.indexOf(functionOutputID.toString)
					  
					if (index > -1){
						error('''funtion «external.function.name» not applicable in «sensor.name» because output variables not unique''', IoTPackage.eINSTANCE.external_Function)
					}
					
					if (functionOutputID.toString == sensor.vars.name.toString){ 
						error('''funtion «external.function.name» not applicable in «sensor.name» because sensor variable not unique''', IoTPackage.eINSTANCE.external_Function)
		 			}
					
				}
			} catch (Exception e) {
				return
			}
		} 
	}
	
	def List<String> getBoardSerialChannels(List<Sensor> sensors){
		val serialOutputs = newArrayList()
		for (Sensor sensor : sensors){
			sensor.output.forEach[so | so.channel.forEach[ c |
					if ((c as Channel).ifSerialType && !serialOutputs.contains((c as Channel).name.toString))
						serialOutputs.add((c as Channel).name.toString) 
				]  
			] 
		} 
		serialOutputs
	} 
	
	def List<String> getBoardMQTTChannels(List<Sensor> sensors){
		val mqttOutputs = newArrayList()
		for (Sensor sensor : sensors){
			sensor.output.forEach[so | so.channel.forEach[ c |
					if ((c as Channel).ifMQTTType && !mqttOutputs.contains((c as Channel).name.toString))
						mqttOutputs.add((c as Channel).name.toString) 
				]  
			] 
		} 
		mqttOutputs
	} 
	
	def List<String> getBoardWiFiChannels(List<Sensor> sensors){
		val serverOutputs = newArrayList()
		for (Sensor sensor : sensors){
			sensor.output.forEach[so | so.channel.forEach[ c |
					if ((c as Channel).ifServerType && !serverOutputs.contains((c as Channel).name.toString))
						serverOutputs.add((c as Channel).name.toString) 
				]  
			] 
		} 
		serverOutputs
	}
	
	def int throwDifferentChannelsError(int length, String message, EAttribute instance){
		if (length > 1){  
			error(message, instance)
		} 
		return length
	}
	
	def validateCommandSamplersBaud(List<Sensor> sensors, int serials, EAttribute instance){
		for (Sensor s : sensors) 
			if ( s.sampler instanceof Command && (s.sampler as Command).baud > 0 && serials > 0)	
				error('''only one serial communication can be declared per board''', instance)
	}
	    
	@Check
	def validateAbstractBoard(AbstractBoard board){
		val serials = board.sensors.boardSerialChannels.size.throwDifferentChannelsError('''the use of different serial channels is prohibited''', IoTPackage.eINSTANCE.abstractBoard_Name)
		board.sensors.validateCommandSamplersBaud(serials, IoTPackage.eINSTANCE.abstractBoard_Name)
		board.sensors.boardMQTTChannels.size.throwDifferentChannelsError('''the use of different mqtt channels is prohibited''', IoTPackage.eINSTANCE.abstractBoard_Name)
		board.sensors.boardWiFiChannels.size.throwDifferentChannelsError('''the use of different wifi channels is prohibited''', IoTPackage.eINSTANCE.abstractBoard_Name)
        
		if(!board.version.validateSDparams) { 
        	error('''this board needs an SD card configuration''', IoTPackage.eINSTANCE.abstractBoard_Name)
        }
	} 
	
	@Check 
	def validateExtendsBoard(ExtendsBoard board){
		val sensors = board.sensors?.toList + board.abstractBoard.sensors.toList
		val serials = sensors.toList.boardSerialChannels 
		board.sensors.validateCommandSamplersBaud(serials.size, IoTPackage.eINSTANCE.board_Name)
		new HashSet<String>(serials).size.throwDifferentChannelsError('''the use of different serial channels is prohibited''', IoTPackage.eINSTANCE.board_Name)
		board.sensors.boardMQTTChannels.size.throwDifferentChannelsError('''the use of different mqtt channels is prohibited''', IoTPackage.eINSTANCE.board_Name)	
		board.sensors.boardWiFiChannels.size.throwDifferentChannelsError('''the use of different wifi channels is prohibited''', IoTPackage.eINSTANCE.board_Name)
		
		if (board.wifiSelect === null){
			for (Sensor sensor : sensors){ 
				sensor.output.forEach[so | 
					if (so.channel.toList.ifChannelsWifiDependent.length > 0) {
						error('''«board.name» extends a board with a WiFi dependency''', IoTPackage.eINSTANCE.board_Name)
					}
				] 
			} 
		} 
		
		if(!board.abstractBoard.version.validateSDparams) {
        	error('''this board needs an SD card configuration''', IoTPackage.eINSTANCE.board_Name)
        }	
	}  
	
	def boolean validateSDparams(BoardVersion version){
		if(Boards.getBoardSupported(version).isNull) {
			if (version !== null){ 
				if (version.sdconfig === null){
					return false
				} else {
					return true
				}
			}
			return false 
        }	 
        true
	} 
	  
	@Check  
	def validateNewBoard(NewBoard board){
		if(!board.version.validateSDparams) {
        	error('''this board needs an SD card configuration''', IoTPackage.eINSTANCE.board_Name)
        }	
		val serials = board.sensors.toList.boardSerialChannels
		board.sensors.validateCommandSamplersBaud(serials.size, IoTPackage.eINSTANCE.board_Name)
		serials.size.throwDifferentChannelsError('''the use of different serial channels is prohibited''', IoTPackage.eINSTANCE.board_Name)
		board.sensors.boardMQTTChannels.size.throwDifferentChannelsError('''the use of different mqtt channels is prohibited''', IoTPackage.eINSTANCE.board_Name)
		board.sensors.boardWiFiChannels.size.throwDifferentChannelsError('''the use of different wifi channels is prohibited''', IoTPackage.eINSTANCE.board_Name)
	 
	}  
	 
	def List<String> ifChannelsWifiDependent(List<Channel> channels){
		var wifiChannels = newArrayList()
		for(Channel channel : channels){
			if (channel.config instanceof Cloud || channel.config instanceof MqttClient || (channel.ctype !== null && channel.ctype.name == "cloud"))
				wifiChannels.add(channel.name)
		}  
		wifiChannels
	}
	
	@Check
	def validateSensorHasWifiConnection(SensorOutput output){
		val channels = output.channel
		var board = output.getContainerOfType(Board) 
		var wifiChannels = channels.ifChannelsWifiDependent
		if (wifiChannels.length > 0){  
			val wifi = board.wifiSelect !== null   
			if (!wifi){ 
				error('''«wifiChannels.toString.replace(',', ' and').replace('[', '').replace(']', '')», is not applicable without a wifi connection''', IoTPackage.eINSTANCE.sensorOutput_Channel)
			}
		}
		
	}
	 
	@Check 
	def validateReferenceNotIgnored(Reference reference){ 
		if (reference.ref == "_"){ 
			error('''cannot parse ignored variables''', IoTPackage.eINSTANCE.reference_Ref)
		}
	}
	 
	@Check 
	def validateLastPipeIsWindow(WindowPipeline pipeline){
		var next = pipeline.next
		if (next !== null){ 
			error('''byWindow cannot be followed by another pipeline''', IoTPackage.eINSTANCE.pipeline_Next)
		}
		var map = pipeline.getContainerOfType(MapPipeline)
		if (map !== null && !(map as Map).expression.type.isNumberType){
			error('''byWindow can only be used on numbers''', IoTPackage.eINSTANCE.pipeline_Next)
		}  
	}
	
	def Iterable<IEObjectDescription> getGlobalEObjectsOfType(Model model, EClass type){
		var scope = scopeProvider.getResourceDescriptions(model.eResource)
		val objs  = scope.getExportedObjectsByType(type)
		objs
	}
	
	def List<String> getListQualifiedNames(Iterable<IEObjectDescription> descriptions){
		var list = newArrayList()
		for (IEObjectDescription description : descriptions){
			
			// xtend builds on java and thus "." must be escaped as java defaults to regex
			var name = description.name.toString.split('\\.') 
			if (name.size() > 1)
				list.add(name.get(name.size()-1))  
			else 
				list.add(name.get(0))
		}
		list
	}
	
	def boolean validateOccursOnce(List<String> list, String name){
		var counter = 0
		for (String currentName : list){
			if (name == currentName)
				counter++
		} 
		if (counter > 1)
			return true
		false
	}
	
	@Check(CheckType.NORMAL) 
	def validateBoardNamesUniversallyUnique(Board board){
		val boards = board.getContainerOfType(Model).getGlobalEObjectsOfType(IoTPackage.eINSTANCE.board)
		val dublicate = boards.listQualifiedNames.validateOccursOnce(board.name)
		if (dublicate)  
			error('''board name "«board.name»" is already taken''', IoTPackage.Literals.BOARD__NAME)
	}
	
	def boolean validateChannelType(ChannelType channelType){
		val name = channelType.name
		val validNames = Arrays.asList("mqtt", "serial", "cloud") 
		if (!validNames.contains(name)){
			return true
		}
		return false
	} 
	
	@Check
	def validateChannelSanity(Channel channel){ 
		val channels = channel.getContainerOfType(Model).getGlobalEObjectsOfType(IoTPackage.eINSTANCE.channel)
		val dublicate = channels.listQualifiedNames.validateOccursOnce(channel.name) 
		if (dublicate)   
			error('''channel name "«channel.name»" is already taken''', IoTPackage.Literals.CHANNEL__NAME)
			
		val configExists = channel.config === null
		val typeExists = channel.ctype === null
		if (!typeExists.and(configExists)){
			error('''either type or configuration must be defined explicitly''', IoTPackage.Literals.CHANNEL__NAME)	
		}  
		 
		if (!typeExists && channel.ctype.validateChannelType){
			error('''invalid channel type''', IoTPackage.Literals.CHANNEL__CTYPE, INVALID_CHANNEL_TYPE, channel.ctype.toString)
		}
	}  
	
	@Check(CheckType.NORMAL) 
	def validateFunctionNamesUniversallyUnique(Function function){ 
		val functions = function.getContainerOfType(Model).getGlobalEObjectsOfType(IoTPackage.eINSTANCE.function)
		val dublicate = functions.listQualifiedNames.validateOccursOnce(function.name) 
		if (dublicate)     
			error('''function name "«function.name»" is already taken''', IoTPackage.Literals.FUNCTION__NAME)
	} 
	
	@Check  
	def validateFunctionType(FunctionInputType function){
		if (function.type.ifInvalid)    
			error('''invalid type''', IoTPackage.eINSTANCE.functionInputType_Name, INVALID_FUNCTION_TYPE, function.name)
		
	} 
	
	def asStringList(List<Variable> vars){
		val list = newArrayList()
		for (Variable variable : vars){
			list.add(variable.name)
		}
		list		
	}
	 
	def asStringListSensor(List<Sensor> vars){
		val list = newArrayList()
		for (Sensor sensor : vars){
			list.add(sensor.name)
		}
		list		
	}
	
	def boolean appearsOnce(List<String> list, String name){
		var counter = 0
		for(String actual : list){
			if (actual == name)
				counter++
		}
		if (counter > 1) 
			return false
		return true
	}
	
	def boolean appearsOnce(List<Integer> list, Integer name){
		var counter = 0
		for(Integer actual : list){
			if (actual == name)
				counter++
		}
		if (counter > 1) 
			return false
		return true
	}
	
	@Check 
	def validateSensorNamesUniversallyUnique(Sensor sensor){
		val error = sensor.getContainerOfType(Model).getGlobalEObjectsOfType(IoTPackage.eINSTANCE.sensor).listQualifiedNames.appearsOnce(sensor.name)
		 
		var abstractContainer = sensor.getContainerOfType(AbstractBoard)
		if (!error && abstractContainer !== null && abstractContainer.sensors.asStringListSensor.appearsOnce(sensor.name)){
			info('''«sensor.name» might be overwritten''', IoTPackage.Literals.SENSOR__NAME)
		}  
		
		var extendsBoard = sensor.getContainerOfType(ExtendsBoard) 
		var abstractBoard = extendsBoard.abstractBoard 
		if (!error && abstractBoard !== null && abstractBoard.sensors.asStringListSensor.appearsOnce(sensor.name)){
			if (!extendsBoard.sensors?.asStringListSensor.appearsOnce(sensor.name)) 
				error('''sensor names must be unique within the context of a board''', IoTPackage.Literals.SENSOR__NAME)
			else
				info('''overriding «sensor.name» in «abstractBoard.name»''', IoTPackage.Literals.SENSOR__NAME)
		}   
		   
		var newBoard = sensor.getContainerOfType(NewBoard)    
		if (!newBoard.sensors.asStringListSensor.appearsOnce(sensor.name))
			error('''sensor names must be unique within the context of a board''', IoTPackage.Literals.SENSOR__NAME)
	}    
	  
	@Check
	def validateBoardVersion(BoardVersion boardVersion){
		val board = Boards.getBoardSupported(boardVersion.type, boardVersion.model)
		if (board.sensors.size() > 0){ 
			info('''«board.toString» supports the following sensors: «board.infoMessage»''', IoTPackage.Literals.BOARD_VERSION__TYPE)
		}
	}
	 
	def validateEmbeddedSensorVariables(Boards board, String sensor, List<Variable> vars, EReference ref){
		if (board.supportsSensor(sensor)) 
			if (board.getVariableCount(sensor) != vars.size()){
				error('''«sensor» outputs «board.getVariableCount(sensor)» variables''', ref)
			} 
	}
	
	def List<Sensor> appendIfNotOverwritten(List<Sensor> sensors1, List<Sensor> sensors2){
		val nsensorsNames = newArrayList()
		val nsensors = newArrayList()
		sensors1.forEach[s | nsensorsNames.add(s.name) nsensors.add(s)]
		sensors2.forEach[s | if (!nsensorsNames.contains(s.name)) nsensors.add(s)]
		nsensors
	}  
	
	def List<String> extractSensorOutputVarName(List<Sensor> sensors){
		val vars = newArrayList()
		sensors.forEach[s | vars.add(s.vars.name)]
		vars
	}
	   
	@Check
	def validateSensorVariables(SensorVariables sensorVars){ 
		val board = sensorVars.getContainerOfType(Board)
		var sensorv = (board instanceof ExtendsBoard ? board.sensors.appendIfNotOverwritten((board as ExtendsBoard).abstractBoard.sensors) : board?.sensors)?.extractSensorOutputVarName 
		if (board === null){
			sensorv = sensorVars.getContainerOfType(AbstractBoard).sensors.extractSensorOutputVarName
		}     
		if (!sensorv.appearsOnce(sensorVars.name)){
			error('''tuple variable "«sensorVars.name»" is already taken''', IoTPackage.eINSTANCE.sensorVariables_Name)
		} 
		  
		if (sensorVars.ids.asStringList.contains(sensorVars.name)){ 
	 		error('''tuple variable "«sensorVars.name»" cannot be used as value''', IoTPackage.eINSTANCE.sensorVariables_Name)
	 	}
	}  
	 
	@Check
	def validateEmbeddedSensorVariables(Sensor sensor){
		 
		val nboard = sensor.getContainerOfType(NewBoard) 
		if (nboard !== null){
			val board = Boards.getBoardSupported(nboard.version)
			board.validateEmbeddedSensorVariables(sensor.sensortype.name, sensor.vars.ids, IoTPackage.eINSTANCE.sensor_Vars)
			return;
		} 
		val eboard = sensor.getContainerOfType(ExtendsBoard) 
		if (eboard !== null){
			val board = Boards.getBoardSupported(eboard.abstractBoard.version)
			board.validateEmbeddedSensorVariables(sensor.sensortype.name, sensor.vars.ids, IoTPackage.eINSTANCE.sensor_Vars)
			return
		}
		val aboard = sensor.getContainerOfType(AbstractBoard)  
		if (aboard !== null){ 
			val board = Boards.getBoardSupported(aboard.version)
			board.validateEmbeddedSensorVariables(sensor.sensortype.name, sensor.vars.ids, IoTPackage.eINSTANCE.sensor_Vars)
		}
	}  
		 
	@Check  
	def validateEmbeddedSensor(EmbeddedSensor onbSensor){ 	 	
		var boardVersion = onbSensor.getContainerOfType(NewBoard)  
		
		if (boardVersion !== null){
			val board = Boards.getBoardSupported(boardVersion.version)		 
			     
			if (!board.supportsSensor(onbSensor.name)){ 
				error('''«board.toString» does not support «onbSensor.name»''', IoTPackage.eINSTANCE.sensorType_Name, NO_SUPPORT_FOR_SENSOR, onbSensor.name)
			} 
			return;
		} 
		
		var extendsVersion = onbSensor.getContainerOfType(ExtendsBoard)?.abstractBoard  
		
		if (extendsVersion !== null){ 
			val board = Boards.getBoardSupported(extendsVersion.version)		
			       
			if (!board.supportsSensor(onbSensor.name)){  
				error('''«extendsVersion.name» does not support «onbSensor.name»''', IoTPackage.eINSTANCE.sensorType_Name, NO_SUPPORT_FOR_SENSOR, onbSensor.name)
			} 
			return;
		}  
		 
		var abstractVersion = onbSensor.getContainerOfType(AbstractBoard)  
		  
		if (abstractVersion !== null){ 
			val board = Boards.getBoardSupported(abstractVersion.version)		
			        
			if (!board.supportsSensor(onbSensor.name)){  
				error('''«board.toString» does not support «onbSensor.name»''', IoTPackage.eINSTANCE.sensorType_Name, NO_SUPPORT_FOR_SENSOR, onbSensor.name)
			} 
		}  
	}  
	
	@Check
	def validateWifiConfig(WifiConfig channel){ 
		if (channel.pass !== null){ 
			warning("sensitive information should not be displayed in the code", IoTPackage.eINSTANCE.wifiConfig_Pass)				
		}
	}
	
	@Check 
	def validateMQTTClient(MqttClient mqtt){
		var ipAddress = mqtt.broker.split('\\.') 
		
		if (ipAddress.size() < 4){
			error("not a valid ip address", IoTPackage.eINSTANCE.mqttClient_Broker)
		}
		
		for (String str : ipAddress){
			val integer = Integer.parseInt(str)
			
			if (integer < 0){
				error("address cannot be less than 0", IoTPackage.eINSTANCE.mqttClient_Broker)
			}
			
			if (integer > 255){ 
				error("address cannot be larger than 255", IoTPackage.eINSTANCE.mqttClient_Broker)
			}
		}
	} 
	
	def validateTypes(TypeChecker.Type actual, TypeChecker.Type expected, EStructuralFeature error) {
		if (expected != actual) {
			error('''expected «expected» got «actual»''', error)
		}
	}

	def validateNumbers(TypeChecker.Type type, EStructuralFeature error) {
		if (!type.isNumberType) {
			error('''expected number got «type»''', error)
		}			
	}
	
	def ifPINSContainSD(Boards board, SDConfig sd, List<Integer> pins, EStructuralFeature error){
		var lst = newArrayList()
		
		if (sd !== null){			
			lst.add(sd.clk)
			lst.add(sd.cs)
			lst.add(sd.sdo)
			lst.add(sd.di)
			lst.ifPINSContainSD(pins, error)
		} else {
			board.SDParameters.ifPINSContainSD(pins, error)
		}
	}
	 
	def ifPINSContainSD(List<Integer> sd, List<Integer> pins, EStructuralFeature error){
		for (Integer i : sd){
			if (pins.contains(i) || !pins.appearsOnce(i)){
				val msg = '''PINs cannot be duplicated'''
				error(msg, error)
			}
		}
	} 
	
	@Check
	def validatePINSdoesNotOverlapWithSD(ExternalSensor sensor){
		val pins = sensor.pins
		var board = sensor.getContainerOfType(Board)
		if (board === null){   
			var config = (board as AbstractBoard).version.sdconfig
			Boards.getBoardSupported((board as AbstractBoard).version).ifPINSContainSD(config, pins, IoTPackage.eINSTANCE.externalSensor_Pins)
		} else if (board instanceof ExtendsBoard){
			var config = (board as ExtendsBoard).abstractBoard.version.sdconfig
			Boards.getBoardSupported((board as ExtendsBoard).abstractBoard.version).ifPINSContainSD(config, pins, IoTPackage.eINSTANCE.externalSensor_Pins)
		} else {    
			var config = (board as NewBoard).version.sdconfig
			Boards.getBoardSupported((board as NewBoard).version).ifPINSContainSD(config, pins, IoTPackage.eINSTANCE.externalSensor_Pins)
		}  
	}

	@Check
	def checkExpression(Conditional conditional) {
		if (conditional.condition !== null)
			conditional.condition.type.validateTypes(TypeChecker.Type.BOOLEAN, IoTPackage.Literals.CONDITIONAL__CONDITION)  
		if (conditional.incorrect !== null)
			if (!conditional.correct.type.isNumberType)
				conditional.incorrect.type.validateTypes(conditional.correct.type, IoTPackage.Literals.CONDITIONAL__INCORRECT)
	}  

	@Check
	def checkExpression(Or or) {
		if (or.left !== null)
			or.left.type.validateTypes(TypeChecker.Type.BOOLEAN, IoTPackage.Literals.OR__LEFT)
		if (or.right !== null)
			or.right.type.validateTypes(TypeChecker.Type.BOOLEAN, IoTPackage.Literals.OR__RIGHT)
	}

	@Check
	def checkExpression(And and) {
		if (and.left !== null)
			and.left.type.validateTypes(TypeChecker.Type.BOOLEAN, IoTPackage.Literals.AND__LEFT)
		if (and.right !== null)
			and.right.type.validateTypes(TypeChecker.Type.BOOLEAN, IoTPackage.Literals.AND__RIGHT)
	}

	@Check
	def checkExpression(Equal equal) {
		if (equal.left !== null && equal.right !== null)
			if (!equal.left.type.isNumberType || !equal.right.type.isNumberType) {
				equal.right.type.validateTypes(equal.left.type, IoTPackage.Literals.EQUAL__RIGHT)
			}
	}

	@Check
	def checkExpression(Unequal unequal) {
		if (unequal.left !== null && unequal.right !== null)
			if (!unequal.left.type.isNumberType || !unequal.right.type.isNumberType) {
				unequal.right.type.validateTypes(unequal.left.type, IoTPackage.Literals.UNEQUAL__RIGHT)
			}
	}

	@Check
	def checkExpression(LessThan lessThan) {
		if (lessThan.left !== null)
			lessThan.left.type.validateNumbers(IoTPackage.Literals.LESS_THAN__LEFT)
		if (lessThan.right !== null)
			lessThan.right.type.validateNumbers(IoTPackage.Literals.LESS_THAN__RIGHT)
	}

	@Check
	def checkExpression(LessThanEqual lessThanEqual) {
		if (lessThanEqual.left !== null)
			lessThanEqual.left.type.validateNumbers(IoTPackage.Literals.LESS_THAN_EQUAL__LEFT)
		if (lessThanEqual.right !== null)
			lessThanEqual.right.type.validateNumbers(IoTPackage.Literals.LESS_THAN_EQUAL__RIGHT)
	}

	@Check
	def checkExpression(GreaterThan greaterThan) {
		if (greaterThan.left !== null && greaterThan.right !== null){
			greaterThan.left.type.validateNumbers(IoTPackage.Literals.GREATER_THAN__LEFT)
			greaterThan.right.type.validateNumbers(IoTPackage.Literals.GREATER_THAN__RIGHT)
		}		
	}
  
	@Check
	def checkExpression(GreaterThanEqual greaterThanEqual) {
		if (greaterThanEqual.left !== null && greaterThanEqual.right !== null){
			greaterThanEqual.left.type.validateNumbers(IoTPackage.Literals.GREATER_THAN_EQUAL__LEFT)
			greaterThanEqual.right.type.validateNumbers(IoTPackage.Literals.GREATER_THAN_EQUAL__RIGHT)
		}	
	}

	@Check
	def checkExpression(Plus plus) {
		if (plus.left !== null && plus.right !== null)
			plus.left.type.validateNumbers(IoTPackage.Literals.PLUS__LEFT)
			plus.right.type.validateNumbers(IoTPackage.Literals.PLUS__RIGHT)
			
	}

	@Check
	def checkExpression(Minus minus) {
		if (minus.left !== null && minus.right !== null) {			
			minus.left.type.validateNumbers(IoTPackage.Literals.MINUS__LEFT)
			minus.right.type.validateNumbers(IoTPackage.Literals.MINUS__RIGHT)
		}
	}

	@Check
	def checkExpression(Mul mul) {
		if (mul.left !== null)
			mul.left.type.validateNumbers(IoTPackage.Literals.MUL__LEFT)
		if (mul.right !== null)
			mul.right.type.validateNumbers(IoTPackage.Literals.MUL__RIGHT)
	}

	@Check
	def checkExpression(Div div) {
		if (div.left !== null)
			div.left.type.validateNumbers(IoTPackage.Literals.DIV__LEFT)
		if (div.right !== null)
			div.right.type.validateNumbers(IoTPackage.Literals.DIV__RIGHT)
	}

	@Check
	def checkExpression(Negation negation) {
		if (negation.value !== null)
			negation.value.type.validateNumbers(IoTPackage.Literals.NEGATION__VALUE)
	}

	@Check
	def checkExpression(Exponent exponent) {
		if (exponent.base !== null)
			exponent.base.type.validateNumbers(IoTPackage.Literals.EXPONENT__BASE)
		if (exponent.power !== null)
			exponent.power.type.validateNumbers(IoTPackage.Literals.EXPONENT__POWER)
	}

	@Check 
	def checkPower(Not not) {  
		if (not.value !== null)
			not.value.type.validateTypes(TypeChecker.Type.BOOLEAN, IoTPackage.Literals.NOT__VALUE)
	}
	
	
}
